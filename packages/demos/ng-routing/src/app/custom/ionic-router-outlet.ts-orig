import {
  ApplicationRef,
  Attribute,
  ChangeDetectorRef,
  ComponentFactoryResolver,
  ComponentRef,
  Directive,
  ElementRef,
  EventEmitter,
  Injector,
  OnDestroy,
  OnInit,
  Output,
  Type,
  ViewContainerRef
} from '@angular/core';

import { PRIMARY_OUTLET, ActivatedRoute, ChildrenOutletContexts } from '@angular/router';

import { RouterDelegate } from './router-delegate';
import { AngularComponentMounter, AngularMountingData } from '@ionic/angular';

let id = 0;

@Directive({
  selector: 'ion-outlet',
})
export class IonicRouterOutlet implements OnDestroy, OnInit {

  public name: string;
  public activationStatus = NOT_ACTIVATED;
  public componentConstructor: Type<any> = null;
  public componentInstance: any = null;
  public activatedRoute: ActivatedRoute = null;
  public activatedRouteData: any = {};
  public activeComponentRef: ComponentRef<any> = null;
  private id: number = id++;

  @Output('activate') activateEvents = new EventEmitter<any>();
  @Output('deactivate') deactivateEvents = new EventEmitter<any>();

  constructor(
    protected appRef: ApplicationRef,
    protected elementRef: ElementRef,
    protected parentContexts: ChildrenOutletContexts,
    protected location: ViewContainerRef,
    protected resolver: ComponentFactoryResolver,
    @Attribute('name') name: string,
    protected changeDetector: ChangeDetectorRef,
    protected mounter: AngularComponentMounter) {

    this.name = name || PRIMARY_OUTLET;
    parentContexts.onChildOutletCreated(this.name, this as any);
  }

  ngOnDestroy(): void {
    this.parentContexts.onChildOutletDestroyed(this.name);
  }

  get isActivated(): boolean {
    return this.activationStatus === ACTIVATION_IN_PROGRESS
      || this.activationStatus === ACTIVATED;
  }

  ngOnInit(): void {
    if (!this.isActivated) {
      // If the outlet was not instantiated at the time the route got activated we need to populate
      // the outlet when it is initialized (ie inside a NgIf)
      const context = this.parentContexts.getContext(this.name);
      if (context && context.route) {
        if (context.attachRef) {
          // `attachRef` is populated when there is an existing component to mount
          this.attach(context.attachRef, context.route);
        } else {
          // otherwise the component defined in the configuration is created
          console.log(`outlet ${this.id} is being activated from ngOnInit: ${this.activationStatus}`);
          this.activateWith(context.route, context.resolver || null);
        }
      }
    }
  }

  get component(): Object {
    return this.componentInstance;
  }

  detach(): ComponentRef<any> {
    return null;
  }

  attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute) {
  }

  deactivate(): void {
    console.log(`outlet ${this.id} is being deactivated`);
    this.activationStatus = NOT_ACTIVATED;
    this.deactivateEvents.emit(this.componentConstructor);
  }

  activateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver|null) {
    if (this.activationStatus !== NOT_ACTIVATED) {
      console.log(`outlet ${this.id} is already activated: ${this.activationStatus}`);
      return;
    }

    console.log(`outlet ${this.id} is starting activation: ${this.activationStatus}`);
    this.activationStatus = ACTIVATION_IN_PROGRESS;
    this.activatedRoute = activatedRoute;
    const snapshot = (activatedRoute as any)._futureSnapshot;
    const component = snapshot.routeConfig ? snapshot.routeConfig.component : null;
    resolver = resolver || this.resolver;
    const factory = resolver.resolveComponentFactory(component);
    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;
    const injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);
    // this.activeComponentRef = this.location.createComponent(factory, this.location.length, injector);
    // Calling `markForCheck` to make sure we will run the change detection when the
    // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.


    return this.mounter.attachViewToDom(this.elementRef.nativeElement, null, component, resolver, injector, {}, []).then((res) => {

      this.changeDetector.markForCheck();
      this.activateEvents.emit(res.instance);
      this.activationStatus = ACTIVATED;
    });

    // console.log('activateWith: ', this.activationStatus);
    /*this.routerComponentMounter.addEntryToQueue({
      activatedRoute,
      componentFactoryResolver: resolver,
      injector,
      elementRef: this.elementRef,
      callback: (data: AngularMountingData) => {
        // console.log('callback!');
        this.changeDetector.markForCheck();
        this.activateEvents.emit(data.instance);
        this.activationStatus = ACTIVATED;
      }
    });
    */
  }
}

class OutletInjector implements Injector {
  constructor(
      private route: ActivatedRoute, private childContexts: ChildrenOutletContexts,
      private parent: Injector) {}

  get(token: any, notFoundValue?: any): any {
    if (token === ActivatedRoute) {
      return this.route;
    }

    if (token === ChildrenOutletContexts) {
      return this.childContexts;
    }

    return this.parent.get(token, notFoundValue);
  }
}

export const NOT_ACTIVATED = 0;
export const ACTIVATION_IN_PROGRESS = 1;
export const ACTIVATED = 2;
